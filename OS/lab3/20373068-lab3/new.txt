typedef struct Buddy{
	u_int start;
	u_int size;
	u_int time;
	u_int mode;
	u_int f;
}Buddy;

Buddy buddy[100000];
int tot;
int time;
void buddy_init(void) {
	u_int start = 0x2000000;
	u_int size = 0x400000;
	int i;
	tot = 8;
	time = 0;
	for (i = 0; i < 8; i++) {
		//一些初始化操作
	}
	//printf("buddy init finish");
}
int buddy_alloc(u_int size, u_int *pa, u_char *pi) {
	u_int min = 0x4000010;
	int index = 0;
	int i;
	for (i = 0; i < tot; i++) {
		//(1)寻找符合要求的地址最低的区间
	}
	if (min == 0x4000010) {
        //没找到
		return -1;
	}
	int pos = findMin(index, size);//(2)进行分裂操作

    
	//(3)获取输出信息


	return 0;
}
int findMin(int i, u_int size) {
	if (buddy[i].size / 2 < size || buddy[i].size == 0x1000) {
		buddy[i].mode = 1; //(1)找到了合适的区间
		return i; 
	}
	time++;
	//(2)新增两个子区间
	return findMin(tot-2, size);//递归分裂
}
void buddy_free(u_int pa) {
	int i;
    //(1)寻找满足条件的区间，采用倒序，效率高一些
	for (i = tot - 1; i >= 0; i--) {
		if (buddy[i].mode == 1 && buddy[i].start == pa) {
			break;
		}
	}
	buddy[i].mode = 0;
    //(2)合并可能的区间
	if (buddy[i].time != 0) {
		merge(buddy[i].time);
	}
}
void merge(u_int time) {
	int a = -1, b = -1, i;
	int flag = 0;
    //获取两个可能可以合并的区间
	for (i = tot - 1; i >= 0; i--) {
		if (buddy[i].mode == 0 && buddy[i].time == time) {
			if (a == -1) {
				a = i;
			} else {
				b = i;
				flag = 1;
				break;
			}
		}
	}
	if (flag) {
		buddy[a].mode = -1;
		buddy[b].mode = -1;
        //唤醒他们的父区间，并让两个子区间进入异常态实现舍去。
		buddy[buddy[a].f].mode = 0;
		if ( buddy[buddy[a].f].time != 0) {
			merge(buddy[buddy[a].f].time);
            //递归合并可能的区间
		}
	}
}